{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/zarp/YOUSEF/TECHNOVA-website/lib/auth.ts"],"sourcesContent":["export const AUTH_COOKIE_NAME = \"technova_auth_token\"\r\nexport const AUTH_COOKIE_VALUE = \"authenticated\"\r\n\r\nexport const FAKE_CREDENTIALS = {\r\n    email: \"admin@technova.com\",\r\n    password: \"password123\",\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAO,MAAM,mBAAmB;AACzB,MAAM,oBAAoB;AAE1B,MAAM,mBAAmB;IAC5B,OAAO;IACP,UAAU;AACd"}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///D:/zarp/YOUSEF/TECHNOVA-website/app/login/actions.ts"],"sourcesContent":["\"use server\"\r\n\r\nimport { cookies } from \"next/headers\"\r\nimport { AUTH_COOKIE_NAME, AUTH_COOKIE_VALUE, FAKE_CREDENTIALS } from \"@/lib/auth\"\r\nimport { z } from \"zod\"\r\n\r\nconst loginSchema = z.object({\r\n    email: z.string().email(),\r\n    password: z.string().min(1),\r\n})\r\n\r\nexport async function login(data: z.infer<typeof loginSchema>) {\r\n    const result = loginSchema.safeParse(data)\r\n\r\n    if (!result.success) {\r\n        return { success: false, error: \"Invalid input\" }\r\n    }\r\n\r\n    const { email, password } = result.data\r\n\r\n    // Use userStore to verify credentials\r\n    // We need to import userStore dynamically or ensure it's available on server\r\n    // Since this is a server action, it runs on server.\r\n    // However, importing from a file that has global state might be tricky in Next.js server actions due to isolation.\r\n    // But for a simple demo with \"use server\", module level variables might persist or might not depending on deployment.\r\n    // For local dev, it usually works but might reset on recompile.\r\n\r\n    // We'll import it at the top level, but for now let's assume standard import works.\r\n    const { userStore } = await import(\"@/lib/user-store\")\r\n\r\n    const user = userStore.verifyCredentials(email, password)\r\n\r\n    if (user) {\r\n        // Set cookie with user email/id to identify them\r\n        // In a real app, use a signed JWT or session ID\r\n        const cookieValue = JSON.stringify({ id: user.id, email: user.email, role: user.role })\r\n\r\n            ; (await cookies()).set(AUTH_COOKIE_NAME, cookieValue, {\r\n                httpOnly: true,\r\n                secure: process.env.NODE_ENV === \"production\",\r\n                sameSite: \"lax\",\r\n                path: \"/\",\r\n                maxAge: 60 * 60 * 24 * 7, // 1 week\r\n            })\r\n        return { success: true }\r\n    }\r\n\r\n    return { success: false, error: \"Invalid email or password\" }\r\n}\r\n\r\nexport async function logout() {\r\n    (await cookies()).delete(AUTH_COOKIE_NAME)\r\n    return { success: true }\r\n}\r\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;;;;AAEA,MAAM,cAAc,uKAAC,CAAC,MAAM,CAAC;IACzB,OAAO,uKAAC,CAAC,MAAM,GAAG,KAAK;IACvB,UAAU,uKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;AAC7B;AAEO,eAAe,MAAM,IAAiC;IACzD,MAAM,SAAS,YAAY,SAAS,CAAC;IAErC,IAAI,CAAC,OAAO,OAAO,EAAE;QACjB,OAAO;YAAE,SAAS;YAAO,OAAO;QAAgB;IACpD;IAEA,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,OAAO,IAAI;IAEvC,sCAAsC;IACtC,6EAA6E;IAC7E,oDAAoD;IACpD,mHAAmH;IACnH,sHAAsH;IACtH,gEAAgE;IAEhE,oFAAoF;IACpF,MAAM,EAAE,SAAS,EAAE,GAAG;IAEtB,MAAM,OAAO,UAAU,iBAAiB,CAAC,OAAO;IAEhD,IAAI,MAAM;QACN,iDAAiD;QACjD,gDAAgD;QAChD,MAAM,cAAc,KAAK,SAAS,CAAC;YAAE,IAAI,KAAK,EAAE;YAAE,OAAO,KAAK,KAAK;YAAE,MAAM,KAAK,IAAI;QAAC;QAE/E,CAAC,MAAM,IAAA,0IAAO,GAAE,EAAE,GAAG,CAAC,+HAAgB,EAAE,aAAa;YACnD,UAAU;YACV,QAAQ,oDAAyB;YACjC,UAAU;YACV,MAAM;YACN,QAAQ,KAAK,KAAK,KAAK;QAC3B;QACJ,OAAO;YAAE,SAAS;QAAK;IAC3B;IAEA,OAAO;QAAE,SAAS;QAAO,OAAO;IAA4B;AAChE;AAEO,eAAe;IAClB,CAAC,MAAM,IAAA,0IAAO,GAAE,EAAE,MAAM,CAAC,+HAAgB;IACzC,OAAO;QAAE,SAAS;IAAK;AAC3B;;;IA1CsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///D:/zarp/YOUSEF/TECHNOVA-website/lib/user-store.ts"],"sourcesContent":["import { FAKE_CREDENTIALS } from \"./auth\"\r\n\r\nexport type User = {\r\n    id: string\r\n    name: string\r\n    email: string\r\n    password: string // In a real app, this should be hashed\r\n    role: \"admin\" | \"user\"\r\n    phone?: string\r\n    image?: string\r\n}\r\n\r\n// Initial admin user\r\nconst initialUsers: User[] = [\r\n    {\r\n        id: \"1\",\r\n        name: \"Admin User\",\r\n        email: FAKE_CREDENTIALS.email,\r\n        password: FAKE_CREDENTIALS.password,\r\n        role: \"admin\",\r\n        phone: \"123-456-7890\",\r\n        image: \"\",\r\n    },\r\n]\r\n\r\n// Global variable to store users in memory (server-side)\r\n// Note: This will reset on server restart/rebuild\r\nlet users: User[] = [...initialUsers]\r\n\r\nexport const userStore = {\r\n    getAll: () => users,\r\n\r\n    getByEmail: (email: string) => users.find((u) => u.email === email),\r\n\r\n    getById: (id: string) => users.find((u) => u.id === id),\r\n\r\n    add: (user: Omit<User, \"id\">) => {\r\n        const newUser = { ...user, id: Math.random().toString(36).substr(2, 9) }\r\n        users.push(newUser)\r\n        return newUser\r\n    },\r\n\r\n    update: (id: string, data: Partial<User>) => {\r\n        users = users.map((u) => (u.id === id ? { ...u, ...data } : u))\r\n        return users.find((u) => u.id === id)\r\n    },\r\n\r\n    delete: (id: string) => {\r\n        users = users.filter((u) => u.id !== id)\r\n    },\r\n\r\n    verifyCredentials: (email: string, password: string) => {\r\n        const user = users.find((u) => u.email === email && u.password === password)\r\n        if (user) {\r\n            const { password, ...userWithoutPassword } = user\r\n            return userWithoutPassword\r\n        }\r\n        return null\r\n    },\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAYA,qBAAqB;AACrB,MAAM,eAAuB;IACzB;QACI,IAAI;QACJ,MAAM;QACN,OAAO,+HAAgB,CAAC,KAAK;QAC7B,UAAU,+HAAgB,CAAC,QAAQ;QACnC,MAAM;QACN,OAAO;QACP,OAAO;IACX;CACH;AAED,yDAAyD;AACzD,kDAAkD;AAClD,IAAI,QAAgB;OAAI;CAAa;AAE9B,MAAM,YAAY;IACrB,QAAQ,IAAM;IAEd,YAAY,CAAC,QAAkB,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,KAAK,KAAK;IAE7D,SAAS,CAAC,KAAe,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;IAEpD,KAAK,CAAC;QACF,MAAM,UAAU;YAAE,GAAG,IAAI;YAAE,IAAI,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG;QAAG;QACvE,MAAM,IAAI,CAAC;QACX,OAAO;IACX;IAEA,QAAQ,CAAC,IAAY;QACjB,QAAQ,MAAM,GAAG,CAAC,CAAC,IAAO,EAAE,EAAE,KAAK,KAAK;gBAAE,GAAG,CAAC;gBAAE,GAAG,IAAI;YAAC,IAAI;QAC5D,OAAO,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;IACtC;IAEA,QAAQ,CAAC;QACL,QAAQ,MAAM,MAAM,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;IACzC;IAEA,mBAAmB,CAAC,OAAe;QAC/B,MAAM,OAAO,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,KAAK,KAAK,SAAS,EAAE,QAAQ,KAAK;QACnE,IAAI,MAAM;YACN,MAAM,EAAE,QAAQ,EAAE,GAAG,qBAAqB,GAAG;YAC7C,OAAO;QACX;QACA,OAAO;IACX;AACJ"}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"sources":["file:///D:/zarp/YOUSEF/TECHNOVA-website/app/dashboard/users/actions.ts"],"sourcesContent":["\"use server\"\r\n\r\nimport { z } from \"zod\"\r\nimport { userStore } from \"@/lib/user-store\"\r\nimport { cookies } from \"next/headers\"\r\nimport { AUTH_COOKIE_NAME } from \"@/lib/auth\"\r\n\r\nconst createUserSchema = z.object({\r\n    name: z.string().min(2),\r\n    email: z.string().email(),\r\n    phone: z.string().optional(),\r\n    image: z.string().optional(),\r\n    password: z.string().min(6),\r\n})\r\n\r\nexport async function createUser(data: z.infer<typeof createUserSchema>) {\r\n    // Verify admin\r\n    const cookieStore = await cookies()\r\n    const authCookie = cookieStore.get(AUTH_COOKIE_NAME)\r\n\r\n    if (!authCookie) {\r\n        return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    try {\r\n        const userSession = JSON.parse(authCookie.value)\r\n        // In a real app, verify against DB again\r\n        const currentUser = userStore.getById(userSession.id)\r\n\r\n        if (!currentUser || currentUser.role !== \"admin\") {\r\n            return { success: false, error: \"Unauthorized: Admin access required\" }\r\n        }\r\n    } catch (e) {\r\n        return { success: false, error: \"Invalid session\" }\r\n    }\r\n\r\n    // Check if email exists\r\n    if (userStore.getByEmail(data.email)) {\r\n        return { success: false, error: \"Email already exists\" }\r\n    }\r\n\r\n    userStore.add({\r\n        ...data,\r\n        role: \"user\", // Default role\r\n    })\r\n\r\n    return { success: true }\r\n}\r\n\r\nconst updatePasswordSchema = z.object({\r\n    currentPassword: z.string().min(1),\r\n    newPassword: z.string().min(6),\r\n})\r\n\r\nexport async function updatePassword(data: z.infer<typeof updatePasswordSchema>) {\r\n    const cookieStore = await cookies()\r\n    const authCookie = cookieStore.get(AUTH_COOKIE_NAME)\r\n\r\n    if (!authCookie) {\r\n        return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    try {\r\n        const userSession = JSON.parse(authCookie.value)\r\n        const user = userStore.getById(userSession.id)\r\n\r\n        if (!user) {\r\n            return { success: false, error: \"User not found\" }\r\n        }\r\n\r\n        if (user.password !== data.currentPassword) {\r\n            return { success: false, error: \"Incorrect current password\" }\r\n        }\r\n\r\n        userStore.update(user.id, { password: data.newPassword })\r\n        return { success: true }\r\n\r\n    } catch (e) {\r\n        return { success: false, error: \"Invalid session\" }\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AACA;;;;;;;AAEA,MAAM,mBAAmB,uKAAC,CAAC,MAAM,CAAC;IAC9B,MAAM,uKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;IACrB,OAAO,uKAAC,CAAC,MAAM,GAAG,KAAK;IACvB,OAAO,uKAAC,CAAC,MAAM,GAAG,QAAQ;IAC1B,OAAO,uKAAC,CAAC,MAAM,GAAG,QAAQ;IAC1B,UAAU,uKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;AAC7B;AAEO,eAAe,WAAW,IAAsC;IACnE,eAAe;IACf,MAAM,cAAc,MAAM,IAAA,0IAAO;IACjC,MAAM,aAAa,YAAY,GAAG,CAAC,+HAAgB;IAEnD,IAAI,CAAC,YAAY;QACb,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,IAAI;QACA,MAAM,cAAc,KAAK,KAAK,CAAC,WAAW,KAAK;QAC/C,yCAAyC;QACzC,MAAM,cAAc,iIAAS,CAAC,OAAO,CAAC,YAAY,EAAE;QAEpD,IAAI,CAAC,eAAe,YAAY,IAAI,KAAK,SAAS;YAC9C,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAsC;QAC1E;IACJ,EAAE,OAAO,GAAG;QACR,OAAO;YAAE,SAAS;YAAO,OAAO;QAAkB;IACtD;IAEA,wBAAwB;IACxB,IAAI,iIAAS,CAAC,UAAU,CAAC,KAAK,KAAK,GAAG;QAClC,OAAO;YAAE,SAAS;YAAO,OAAO;QAAuB;IAC3D;IAEA,iIAAS,CAAC,GAAG,CAAC;QACV,GAAG,IAAI;QACP,MAAM;IACV;IAEA,OAAO;QAAE,SAAS;IAAK;AAC3B;AAEA,MAAM,uBAAuB,uKAAC,CAAC,MAAM,CAAC;IAClC,iBAAiB,uKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;IAChC,aAAa,uKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;AAChC;AAEO,eAAe,eAAe,IAA0C;IAC3E,MAAM,cAAc,MAAM,IAAA,0IAAO;IACjC,MAAM,aAAa,YAAY,GAAG,CAAC,+HAAgB;IAEnD,IAAI,CAAC,YAAY;QACb,OAAO;YAAE,SAAS;YAAO,OAAO;QAAe;IACnD;IAEA,IAAI;QACA,MAAM,cAAc,KAAK,KAAK,CAAC,WAAW,KAAK;QAC/C,MAAM,OAAO,iIAAS,CAAC,OAAO,CAAC,YAAY,EAAE;QAE7C,IAAI,CAAC,MAAM;YACP,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAiB;QACrD;QAEA,IAAI,KAAK,QAAQ,KAAK,KAAK,eAAe,EAAE;YACxC,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAA6B;QACjE;QAEA,iIAAS,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE;YAAE,UAAU,KAAK,WAAW;QAAC;QACvD,OAAO;YAAE,SAAS;QAAK;IAE3B,EAAE,OAAO,GAAG;QACR,OAAO;YAAE,SAAS;YAAO,OAAO;QAAkB;IACtD;AACJ;;;IAjEsB;IAuCA;;AAvCA,+OAAA;AAuCA,+OAAA"}},
    {"offset": {"line": 275, "column": 0}, "map": {"version":3,"sources":["file:///D:/zarp/YOUSEF/TECHNOVA-website/.next-internal/server/app/dashboard/users/create/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {logout as '00751cb60d5dbe0503fc7f8ce404a35109ed477e9c'} from 'ACTIONS_MODULE0'\nexport {createUser as '405130bea945612de92122698af8ff3dfcff9838f6'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AACA"}}]
}